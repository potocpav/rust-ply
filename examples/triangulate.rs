#![feature(plugin,path,io)]

#![plugin(ply_plugins)]
extern crate ply_plugins;
extern crate ply;

use std::old_io::File;


#[derive(Debug)]
#[ply_model]
struct Model {
	vertex: Vec<Vertex>,
	face: Vec<Face>,
}

#[derive(Debug,Copy)]
#[ply_element]
pub struct Vertex {
	x: f32, y: f32, z: f32,
}


#[derive(Debug,Copy)]
pub struct Face {
	v1: u32, v2: u32, v3: u32,
}

// We want every Face to be a triangle. But the file contains also quads
// (generated by Blender). We create a manual ply::Element implementation to
// compute triangles from polygons.
impl ply::Element for Face {
	fn check(_: Option<Self>, e: &ply::ElementSpec) -> Result<(),String> {
		if e.props.len() != 1 || e.props[0].type_ != ply::Type::List(Box::new(ply::Type::UInt)) {
			Err("Wrong number of type of properties.".to_string())
		} else {
			Ok(())
		}
	}

	fn parse(e: &ply::ElementSpec) -> Result<Vec<Self>,String> {
		let mut res = Vec::with_capacity(e.data.len());
		for l in e.data.iter() {
			if l.len() < 3 {
				return Err("Cannot make a triangle out of less than 3 points.".to_string());
			}
			let v1: u32 = try!(l[1].parse().map_err(|_|"Can't parse a value.".to_string()));
			let v2: u32 = try!(l[2].parse().map_err(|_|"Can't parse a value.".to_string()));
			for i in l[2..].iter() {
				let v3: u32 = try!(i.parse().map_err(|_|"Can't parse a value.".to_string()));
				res.push(Face {v1: v1, v2: v2, v3: v3});
			}
		}
		Ok(res)
	}
}


fn main() {
	// Load a file
	let path = Path::new("examples/monkey.ply");
	let mut file = File::open(&path).unwrap();
	let text = file.read_to_string().unwrap();

	match ply::parse(&text) { // Create an AST
		Ok(ref ply) => {
			// Fill in the structure from the AST
			let model: Result<Model,_> = ply::Model::new(ply);
			// Print the result
			println!("\nResult: {:?}", model);
		},
		Err(e) => println!("Error while parsing:\n\t{}", e),
	}
}
